<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Field*</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #field-label {
            position: absolute;
            top: 10px;
            left: 20px;
            font-family: Helvetica, Arial, sans-serif;
            font-weight: bold;
            font-size: 50px;
            color: black;
            z-index: 1000;
        }
        #youtube-embed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 320px;
            height: 180px;
            display: none;
        }
        #legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 12px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 5px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div id="field-label">Field*</div>
    <div id="youtube-embed"></div>
    <div id="legend"></div>
    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';

        let scene, camera, renderer, points;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let clickStartTime = 0;
        let clickStartPosition = { x: 0, y: 0 };
        
        const MIN_ZOOM = .5;
        const MAX_ZOOM = 1000;
        const MIN_POINT_SIZE = 0.000001;
        const MAX_POINT_SIZE = 0.01;
        const INTERSECT_THRESHOLD = 0.01;
        const ZOOM_SPEED = 0.01;
        const DRAG_SPEED_MULTIPLIER = 1;

        const styleColors = {};

        init();

        async function init() {
            [scene, camera, renderer] = createScene();
            document.body.appendChild(renderer.domElement);

            const data = await loadAndProcessData();
            points = createPoints(data);
            scene.add(points);

            addEventListeners();
            animate();
        }

        function createScene() {
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0); // Light gray background
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            return [scene, camera, renderer];
        }

        async function loadAndProcessData() {
            try {
                const response = await fetch('music_embeddings_with_umap.json.gz');
                const arrayBuffer = await response.arrayBuffer();
                const decompressedData = await new Response(
                    new Blob([arrayBuffer]).stream().pipeThrough(new DecompressionStream('gzip'))
                ).arrayBuffer();
                return JSON.parse(new TextDecoder().decode(decompressedData));
            } catch (error) {
                console.error('Error loading or processing data:', error);
                return [];
            }
        }

        function createPoints(data) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(data.length * 3);
            const colors = new Float32Array(data.length * 3);

            data.forEach((point, i) => {
                const i3 = i * 3;
                positions.set([point.umap_x, point.umap_y, 0], i3);
                
                // Set all points to gray
                colors.set([0.5, 0.5, 0.5], i3);
            });

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const texture = createCircleTexture();
            const material = new THREE.PointsMaterial({
                size: MAX_POINT_SIZE,
                vertexColors: true,
                map: texture,
                transparent: true,
                opacity: 1,
                alphaTest: 0.5
            });

            const points = new THREE.Points(geometry, material);
            points.userData.data = data;
            points.userData.originalColors = colors.slice();
            return points;
        }

        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            
            context.beginPath();
            context.arc(64, 64, 64, 0, 2 * Math.PI);
            context.fillStyle = 'white';
            context.fill();

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function addEventListeners() {
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (isDragging) {
                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y
                };

                const zoomFactor = camera.position.z / MAX_ZOOM;
                const dragSpeed = DRAG_SPEED_MULTIPLIER * zoomFactor;

                camera.position.x -= deltaMove.x * dragSpeed;
                camera.position.y += deltaMove.y * dragSpeed;

                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }

        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
            clickStartTime = Date.now();
            clickStartPosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseUp(event) {
            isDragging = false;
            const clickEndTime = Date.now();
            const clickDuration = clickEndTime - clickStartTime;
            const clickEndPosition = { x: event.clientX, y: event.clientY };
            const clickDistance = Math.sqrt(
                Math.pow(clickEndPosition.x - clickStartPosition.x, 2) +
                Math.pow(clickEndPosition.y - clickStartPosition.y, 2)
            );

            if (clickDuration < 200 && clickDistance < 5) {
                const intersects = getIntersects();
                if (intersects.length > 0) {
                    const clickedPoint = points.userData.data[intersects[0].index];
                    if (clickedPoint) {
                        highlightStyles(clickedPoint);
                        if (clickedPoint.youtube_uri) {
                            embedYouTube(clickedPoint.youtube_uri);
                        }
                    }
                }
            }
        }

        function onMouseWheel(event) {
            event.preventDefault();
            const newZoom = camera.position.z + event.deltaY * ZOOM_SPEED;
            camera.position.z = THREE.MathUtils.clamp(newZoom, MIN_ZOOM, MAX_ZOOM);
            updatePointSize();
        }

        function updatePointSize() {
            const zoomFactor = (camera.position.z - MIN_ZOOM) / (MAX_ZOOM - MIN_ZOOM);
            const newSize = THREE.MathUtils.lerp(MAX_POINT_SIZE, MIN_POINT_SIZE, zoomFactor);
            points.material.size = newSize;
        }

        function getIntersects() {
            raycaster.setFromCamera(mouse, camera);
            raycaster.params.Points.threshold = INTERSECT_THRESHOLD;
            return raycaster.intersectObject(points);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function highlightStyles(selectedPoint) {
            const colors = points.geometry.attributes.color;
            const originalColors = points.userData.originalColors;

            // Reset all colors to original (gray)
            colors.array.set(originalColors);

            // Assign colors to the styles of the selected track
            selectedPoint.styles.forEach((style) => {
                if (!styleColors[style]) {
                    styleColors[style] = generateDeterministicColor(style);
                }
                const color = styleColors[style];
                
                points.userData.data.forEach((point, i) => {
                    if (point.styles.includes(style)) {
                        const i3 = i * 3;
                        colors.array[i3] = color.r;
                        colors.array[i3 + 1] = color.g;
                        colors.array[i3 + 2] = color.b;
                    }
                });
            });

            colors.needsUpdate = true;

            // Update the legend
            updateLegend(selectedPoint.styles);
        }

        function generateDeterministicColor(style) {
            let hash = 0;
            for (let i = 0; i < style.length; i++) {
                hash = style.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            const hue = (hash % 360 + 360) % 360; // Ensure positive hue value
            const saturation = 70 + (hash % 30); // 70-100%
            const lightness = 40 + (hash % 20); // 40-60%

            return new THREE.Color(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
        }

        function updateLegend(styles) {
            const legend = document.getElementById('legend');
            legend.innerHTML = '<h3>Selected Track Styles</h3>';
            styles.forEach(style => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = `#${styleColors[style].getHexString()}`;
                const label = document.createElement('span');
                label.textContent = style;
                item.appendChild(colorBox);
                item.appendChild(label);
                legend.appendChild(item);
            });
        }

        function embedYouTube(youtubeUri) {
            const embedContainer = document.getElementById('youtube-embed');
            const videoId = youtubeUri.split('v=')[1];
            if (videoId) {
                embedContainer.innerHTML = `<iframe width="320" height="180" src="https://www.youtube.com/embed/${videoId}" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>`;
                embedContainer.style.display = 'block';
            }
        }
    </script>
</body>
</html>